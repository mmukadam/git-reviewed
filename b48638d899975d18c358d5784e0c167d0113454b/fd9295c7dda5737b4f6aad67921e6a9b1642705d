>commit b48638d899975d18c358d5784e0c167d0113454b
>Author: Murtuza Mukadam <murtuza16289@gmail.com>
>Date:   Mon Aug 19 11:25:44 2013 -0400
>
>    git review --log now gives a useful message for an unknown commit
>
>diff --git a/scripts/git-review-log b/scripts/git-review-log
>index 088d713..533ced9 100755
>--- a/scripts/git-review-log
>+++ b/scripts/git-review-log
>@@ -2,13 +2,13 @@
> 
> my $commithash = $ARGV[0];
> my $flag = 0; 
>-
>+my $log = '';
> 
> if(length($commithash) != 0)
>  {
>    $flag =1;
>  } 
>-print $ARGV[0];
>+
this is a test review 
> OUTER:
> foreach my $rev (`git rev-list review --pretty=oneline`) {
>@@ -36,11 +36,15 @@ foreach my $val (@values1) {
>             
>             next OUTER;
>   }
>-        
>+      $log = $log."\nReview ";
>       print "\nReview ";
>-         
>-          print $val1;
>+        
>+         $log = $log."$val1";  
>+        print $val1;
>+
>+      $log = $log."commit Reviewed  "; 
>       print "commit Reviewed ";
>+      $log = $log."$val\n"; 
>       print "$val\n";
>  }
> 
>@@ -56,22 +60,35 @@ foreach my $val (@values1) {
>    my $log_response = (split('Response to', $log))[1];
>    my $removemessage = (split('\n\n', $log))[0];
>    
>-  
>+  $log = $log."$removemessage\n";
>    print "$removemessage\n";
>    
>    if($log_amend)
>     {
>+
>+      $log = $log."Amended Review";
>       print "Amended Review"; 
>-       print "$log_amend";
>+     $log = $log."$log_amend";      
>+      print "$log_amend";
>     }
>    
> 
>     
>    if($log_response)
>     {
>-      print "Response to"; 
>+       $log = $log."Response to";
>+      print "Response to";
>+       $log = $log."$log_response"; 
>        print "$log_response";
>     }
>     
>    
> }
>+
>+if ($log eq "")
>+ {
>+   
>+   print "fatal: bad revision $commithash\n";
>+   exit;
>+ }
>+
>diff --git a/scripts/patch-commit-linker/searchMatch.pl b/scripts/patch-commit-linker/searchMatch.pl
>index 21f75a8..c86a916 100755
>--- a/scripts/patch-commit-linker/searchMatch.pl
>+++ b/scripts/patch-commit-linker/searchMatch.pl
>@@ -57,7 +57,7 @@ while (<>) {
>     } elsif (/^\+(.+)$/ and $file ne '') {
> 	Do_Matching_Line('+', $1);
>     } else {
>-	die if /^Message-ID/i;
>+	#die if /^Message-ID/i;
> 	;
>     }
> }
>@@ -78,12 +78,16 @@ sub Report
> 	foreach my $c (@bestCids) {
> 	    my $count = Count_Lines_In_Commit($c);
> 	    if ($count <= $total) {
>-		print "    $c -> $cids{$c};", $count, ";\n";
>+		print "    commit: $c -> $cids{$c};", $count, ";\n";
> 	    }
>+            else {
>+                print "    commit: not match\n";
>+             }       
> 	}
> 	foreach my $m (@noMatches) {
> 	    print " not match [$m]\n";
> 	}
>+        
>     }
> }
> 
>diff --git a/scripts/patch-commit-linker/searchMatchmurtuza.pl b/scripts/patch-commit-linker/searchMatchmurtuza.pl
>deleted file mode 100755
>index c86a916..0000000
>--- a/scripts/patch-commit-linker/searchMatchmurtuza.pl
>+++ /dev/null
>@@ -1,206 +0,0 @@
>-#!/usr/bin/perl
>-
>-
>-use strict;
>-use DBI;
>-
>-my $dbName = 'lineslinus.db';
>-
>-my $binPath = Get_Execution_Path();
>-
>-
>-my $dbh = DBI->connect(          
>-    "dbi:SQLite:dbname=${binPath}$dbName", 
>-    "",                          
>-    "",                          
>-    { RaiseError => 1 },         
>-) or die $DBI::errstr;
>-
>-my $THRESHOLD = 0;
>-
>-
>-
>-my %cids;
>-my $messageId = '';
>-my $prevEmpty = 1;
>-my $line = '';
>-my $lineType = '';
>-my $file = '';
>-my $matched = 0;
>-my $total = 0;
>-my @noMatches;
>-while (<>) {
>-    chomp;
>-    if (/^From / and $prevEmpty) {
>-	if ($matched > 0) {
>-	    Report();
>-	}
>-	$messageId = '';
>-	$prevEmpty = 0;
>-	$file = '';
>-	$line = '';
>-	$total = 0;
>-	$matched = 0;
>-	%cids = ();
>-	@noMatches = ();
>-    } elsif ($_ eq "") {
>-	$prevEmpty = 1;
>-    } elsif (/^message\-id:\s*(.+)$/i) {
>-	$messageId = $1;
>-#	print "Message id [$messageId]\n";
>-    } elsif (/^\+\+\+ (.+)$/) {
>-	$file = $1;
>-    } elsif (/^\-\-\- (.+)$/) {
>-	; do nothing
>-    } elsif (/^\-(.+)$/ and $file ne '') {
>-	Do_Matching_Line('-', $1);
>-    } elsif (/^\+(.+)$/ and $file ne '') {
>-	Do_Matching_Line('+', $1);
>-    } else {
>-	#die if /^Message-ID/i;
>-	;
>-    }
>-}
>-Report();
>-$dbh->disconnect();
>-exit 0;
>-
>-sub Report
>-{
>-    my $prop = $matched * 1.0 / ($total==0?1:$total);
>-    if ($prop > $THRESHOLD) {
>-	my $commitsCount = scalar (keys %cids);
>-	print "mid;$messageId;cids;$commitsCount;tot;$total;match;$matched;prop;", $prop, "\n" ;
>-	
>-	my @bestCids = Best_Cids(\%cids);
>-	print "    Bestcids: ", scalar(@bestCids), "\n";
>-#		foreach my $c (keys %cids) {
>-	foreach my $c (@bestCids) {
>-	    my $count = Count_Lines_In_Commit($c);
>-	    if ($count <= $total) {
>-		print "    commit: $c -> $cids{$c};", $count, ";\n";
>-	    }
>-            else {
>-                print "    commit: not match\n";
>-             }       
>-	}
>-	foreach my $m (@noMatches) {
>-	    print " not match [$m]\n";
>-	}
>-        
>-    }
>-}
>-
>-sub Count_Lines_In_Commit
>-{
>-    my ($cid) = @_;
>-    return Simple_Query("select count(*) from (select linetype, line from line where cid = '$cid') as rip");
>-}
>-
>-sub Do_Matching_Line
>-{
>-    my ($lineType, $line) = @_;
>-    return unless $line =~ /[a-zA-Z]/;
>-    my @matches = Find_Match_Line($file, $line, $lineType);
>-    $total++;
>-    if (scalar(@matches) == 0) {
>-	; # no matches
>-	push(@noMatches, $line);
>-
>-    } else {
>-	foreach my $c (Find_Match_Line($file, $line, $lineType)) {
>-	    $cids{$c}++;
>-	}
>-	$matched++;
>-    }
>-    
>-}
>-
>-sub Find_Match_Line
>-{
>-    my ($file, $line, $type)  = @_;
>-    
>-    die unless $type eq '+' or $type eq '-';
>-    
>-    $line =~ s/;/<semi>/g;
>-    
>-    #pcr do trim
>-    $line =~ s/^\s*//g;
>-    $line =~ s/\s*$//g;
>-
>-    return Simple_Array_Query("select distinct cid from line where linetype = ? and filename = ? and line = ?", $type, $file, $line);
>-
>-    #pcr: use like instead of =
>-    #$line = '%' . $line . '%';
>-    #like return Simple_Array_Query("select distinct cid from line where linetype = ? and filename = ? and line like ?", $type, $file, $line);
>-
>-}
>-
>-
>-
>-
>-sub Get_Execution_Path
>-{
>-    my $path = $0;
>-    if ($path =~ m@/@) {
>-       $path =~ s@/[^/]+$@/@;
>-    } else {
>-       $path = ""
>-    }
>-    print "path[$path]\n";
>-    return $path;
>-}
>-
>-
>-sub Simple_Query
>-{
>-    my ($query, @parms) = @_;
>-    my $q = $dbh->prepare($query);
>-    $q->execute(@parms);
>-    return $q->fetchrow_array();
>-
>-}
>-
>-sub Simple_Array_Query
>-{
>-    my ($query, @parms) = @_;
>-    my @result;
>-    my $q = $dbh->prepare($query);
>-    $q->execute(@parms);
>-    while (my $item = $q->fetchrow_array()) {
>-	print "$item\n";
>-        push @result, $item;
>-    }
>-    return @result;
>-}
>-
>-sub Best_Cids
>-{
>-    my ($cids) = @_;
>-    if (scalar(%$cids) == 0) {
>-	return undef;
>-    }
>-    my @ordered = Sort_Hash($cids);
>-    foreach my $c (@ordered) {
>-#	print "----->$c -> $$cids{$c}\n";
>-    }
>-
>-    my @returnVals;
>-    my $last =0;
>-    foreach my $t (@ordered) {
>-	if ($$cids{$t} >= $last) {
>-	    push(@returnVals, $t);
>-	    $last = $$cids{$t};
>-	} else {
>-	    return @returnVals;
>-	}
>-    }
>-    return @returnVals;
>-}
>-
>-sub Sort_Hash
>-{
>-    my ($h) = @_;
>-
>-    return (sort {$$h{$b} <=> $$h{$a}} keys %$h);
>-}
